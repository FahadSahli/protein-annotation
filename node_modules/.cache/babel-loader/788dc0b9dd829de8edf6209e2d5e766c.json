{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport { parse as parseArn, validate as validateArn } from \"@aws-sdk/util-arn-parser\";\nimport { bucketHostname } from \"./bucketHostname\";\nimport { getPseudoRegion } from \"./bucketHostnameUtils\";\nexport function bucketEndpointMiddleware(options) {\n  var _this = this;\n\n  return function (next, context) {\n    return function (args) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var bucketName, replaceBucketInPath, request, bucketArn, clientRegion, _a, _b, partition, signingRegion, useArnRegion, _c, hostname, bucketEndpoint, _d, hostname, bucketEndpoint;\n\n        return __generator(this, function (_e) {\n          switch (_e.label) {\n            case 0:\n              bucketName = args.input.Bucket;\n              replaceBucketInPath = options.bucketEndpoint;\n              request = args.request;\n              if (!HttpRequest.isInstance(request)) return [3\n              /*break*/\n              , 7];\n              if (!options.bucketEndpoint) return [3\n              /*break*/\n              , 1];\n              request.hostname = bucketName;\n              return [3\n              /*break*/\n              , 6];\n\n            case 1:\n              if (!validateArn(bucketName)) return [3\n              /*break*/\n              , 5];\n              bucketArn = parseArn(bucketName);\n              _a = getPseudoRegion;\n              return [4\n              /*yield*/\n              , options.region()];\n\n            case 2:\n              clientRegion = _a.apply(void 0, [_e.sent()]);\n              return [4\n              /*yield*/\n              , options.regionInfoProvider(clientRegion)];\n\n            case 3:\n              _b = _e.sent() || {}, partition = _b.partition, signingRegion = _b.signingRegion;\n              return [4\n              /*yield*/\n              , options.useArnRegion()];\n\n            case 4:\n              useArnRegion = _e.sent();\n              _c = bucketHostname({\n                bucketName: bucketArn,\n                baseHostname: request.hostname,\n                accelerateEndpoint: options.useAccelerateEndpoint,\n                dualstackEndpoint: options.useDualstackEndpoint,\n                pathStyleEndpoint: options.forcePathStyle,\n                tlsCompatible: request.protocol === \"https:\",\n                useArnRegion: useArnRegion,\n                clientPartition: partition,\n                clientSigningRegion: signingRegion\n              }), hostname = _c.hostname, bucketEndpoint = _c.bucketEndpoint; // If the request needs to use a region inferred from ARN that different from client region, we need to set\n              // them in the handler context so the signer will use them\n\n              if (useArnRegion && clientRegion !== bucketArn.region) {\n                context[\"signing_region\"] = bucketArn.region;\n              }\n\n              request.hostname = hostname;\n              replaceBucketInPath = bucketEndpoint;\n              return [3\n              /*break*/\n              , 6];\n\n            case 5:\n              _d = bucketHostname({\n                bucketName: bucketName,\n                baseHostname: request.hostname,\n                accelerateEndpoint: options.useAccelerateEndpoint,\n                dualstackEndpoint: options.useDualstackEndpoint,\n                pathStyleEndpoint: options.forcePathStyle,\n                tlsCompatible: request.protocol === \"https:\"\n              }), hostname = _d.hostname, bucketEndpoint = _d.bucketEndpoint;\n              request.hostname = hostname;\n              replaceBucketInPath = bucketEndpoint;\n              _e.label = 6;\n\n            case 6:\n              if (replaceBucketInPath) {\n                request.path = request.path.replace(/^(\\/)?[^\\/]+/, \"\");\n\n                if (request.path === \"\") {\n                  request.path = \"/\";\n                }\n              }\n\n              _e.label = 7;\n\n            case 7:\n              return [2\n              /*return*/\n              , next(__assign(__assign({}, args), {\n                request: request\n              }))];\n          }\n        });\n      });\n    };\n  };\n}\nexport var bucketEndpointMiddlewareOptions = {\n  tags: [\"BUCKET_ENDPOINT\"],\n  name: \"bucketEndpointMiddleware\",\n  relation: \"before\",\n  toMiddleware: \"hostHeaderMiddleware\"\n};\nexport var getBucketEndpointPlugin = function (options) {\n  return {\n    applyToStack: function (clientStack) {\n      clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);\n    }\n  };\n};","map":{"version":3,"sources":["../../src/bucketEndpointMiddleware.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport {\n  BuildHandler,\n  BuildHandlerArguments,\n  BuildHandlerOutput,\n  BuildMiddleware,\n  HandlerExecutionContext,\n  MetadataBearer,\n  Pluggable,\n  RelativeMiddlewareOptions,\n} from \"@aws-sdk/types\";\nimport { parse as parseArn, validate as validateArn } from \"@aws-sdk/util-arn-parser\";\n\nimport { bucketHostname } from \"./bucketHostname\";\nimport { getPseudoRegion } from \"./bucketHostnameUtils\";\nimport { BucketEndpointResolvedConfig } from \"./configurations\";\n\nexport function bucketEndpointMiddleware(options: BucketEndpointResolvedConfig): BuildMiddleware<any, any> {\n  return <Output extends MetadataBearer>(\n    next: BuildHandler<any, Output>,\n    context: HandlerExecutionContext\n  ): BuildHandler<any, Output> => async (args: BuildHandlerArguments<any>): Promise<BuildHandlerOutput<Output>> => {\n    const { Bucket: bucketName } = args.input as { Bucket: string };\n    let replaceBucketInPath = options.bucketEndpoint;\n    const request = args.request;\n    if (HttpRequest.isInstance(request)) {\n      if (options.bucketEndpoint) {\n        request.hostname = bucketName;\n      } else if (validateArn(bucketName)) {\n        const bucketArn = parseArn(bucketName);\n        const clientRegion = getPseudoRegion(await options.region());\n        const { partition, signingRegion } = (await options.regionInfoProvider(clientRegion)) || {};\n        const useArnRegion = await options.useArnRegion();\n        const { hostname, bucketEndpoint } = bucketHostname({\n          bucketName: bucketArn,\n          baseHostname: request.hostname,\n          accelerateEndpoint: options.useAccelerateEndpoint,\n          dualstackEndpoint: options.useDualstackEndpoint,\n          pathStyleEndpoint: options.forcePathStyle,\n          tlsCompatible: request.protocol === \"https:\",\n          useArnRegion,\n          clientPartition: partition,\n          clientSigningRegion: signingRegion,\n        });\n\n        // If the request needs to use a region inferred from ARN that different from client region, we need to set\n        // them in the handler context so the signer will use them\n        if (useArnRegion && clientRegion !== bucketArn.region) {\n          context[\"signing_region\"] = bucketArn.region;\n        }\n\n        request.hostname = hostname;\n        replaceBucketInPath = bucketEndpoint;\n      } else {\n        const { hostname, bucketEndpoint } = bucketHostname({\n          bucketName,\n          baseHostname: request.hostname,\n          accelerateEndpoint: options.useAccelerateEndpoint,\n          dualstackEndpoint: options.useDualstackEndpoint,\n          pathStyleEndpoint: options.forcePathStyle,\n          tlsCompatible: request.protocol === \"https:\",\n        });\n\n        request.hostname = hostname;\n        replaceBucketInPath = bucketEndpoint;\n      }\n\n      if (replaceBucketInPath) {\n        request.path = request.path.replace(/^(\\/)?[^\\/]+/, \"\");\n        if (request.path === \"\") {\n          request.path = \"/\";\n        }\n      }\n    }\n\n    return next({ ...args, request });\n  };\n}\n\nexport const bucketEndpointMiddlewareOptions: RelativeMiddlewareOptions = {\n  tags: [\"BUCKET_ENDPOINT\"],\n  name: \"bucketEndpointMiddleware\",\n  relation: \"before\",\n  toMiddleware: \"hostHeaderMiddleware\",\n};\n\nexport const getBucketEndpointPlugin = (options: BucketEndpointResolvedConfig): Pluggable<any, any> => ({\n  applyToStack: (clientStack) => {\n    clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}