{"ast":null,"code":"var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nvar IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nvar DOTS_PATTERN = /\\.\\./;\nexport var DOT_PATTERN = /\\./;\nexport var S3_HOSTNAME_PATTERN = /^(.+\\.)?s3[.-]([a-z0-9-]+)\\./;\nvar S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\\.amazonaws\\.com$/;\nvar AWS_PARTITION_SUFFIX = \"amazonaws.com\";\nexport var isBucketNameOptions = function (options) {\n  return typeof options.bucketName === \"string\";\n};\nexport var getPseudoRegion = function (region) {\n  return isFipsRegion(region) ? region.replace(/fips-|-fips/, \"\") : region;\n};\n/**\n * Determines whether a given string is DNS compliant per the rules outlined by\n * S3. Length, capitaization, and leading dot restrictions are enforced by the\n * DOMAIN_PATTERN regular expression.\n *\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n */\n\nexport var isDnsCompatibleBucketName = function (bucketName) {\n  return DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\n};\n\nvar getRegionalSuffix = function (hostname) {\n  var parts = hostname.match(S3_HOSTNAME_PATTERN);\n  return [parts[2], hostname.replace(new RegExp(\"^\" + parts[0]), \"\")];\n};\n\nexport var getSuffix = function (hostname) {\n  return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [\"us-east-1\", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n};\nexport var getSuffixForArnEndpoint = function (hostname) {\n  return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [hostname.replace(\".\" + AWS_PARTITION_SUFFIX, \"\"), AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n};\nexport var validateService = function (service) {\n  if (service !== \"s3\") {\n    throw new Error(\"Expect 's3' in access point ARN service component\");\n  }\n};\nexport var validatePartition = function (partition, options) {\n  if (partition !== options.clientPartition) {\n    throw new Error(\"Partition in ARN is incompatible, got \\\"\" + partition + \"\\\" but expected \\\"\" + options.clientPartition + \"\\\"\");\n  }\n};\nexport var validateRegion = function (region, options) {\n  if (region === \"\") {\n    throw new Error(\"Access point ARN region is empty\");\n  }\n\n  if (!options.useArnRegion && !isEqualRegions(region, options.clientRegion) && !isEqualRegions(region, options.clientSigningRegion)) {\n    throw new Error(\"Region in ARN is incompatible, got \" + region + \" but expected \" + options.clientRegion);\n  }\n\n  if (options.useArnRegion && isFipsRegion(region)) {\n    throw new Error(\"Access point endpoint does not support FIPS region\");\n  }\n};\n\nvar isFipsRegion = function (region) {\n  return region.startsWith(\"fips-\") || region.endsWith(\"-fips\");\n};\n\nvar isEqualRegions = function (regionA, regionB) {\n  return regionA === regionB || getPseudoRegion(regionA) === regionB || regionA === getPseudoRegion(regionB);\n};\n\nexport var validateAccountId = function (accountId) {\n  if (!/[0-9]{12}/.exec(accountId)) {\n    throw new Error(\"Access point ARN accountID does not match regex '[0-9]{12}'\");\n  }\n};\nexport var validateDNSHostLabel = function (label, options) {\n  if (options === void 0) {\n    options = {\n      tlsCompatible: true\n    };\n  } // reference: https://tools.ietf.org/html/rfc3986#section-3.2.2\n\n\n  if (label.length >= 64 || !/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(label) || /(\\d+\\.){3}\\d+/.test(label) || /[.-]{2}/.test(label) || (options === null || options === void 0 ? void 0 : options.tlsCompatible) && DOT_PATTERN.test(label)) {\n    throw new Error(\"Invalid DNS label \" + label);\n  }\n};\nexport var getAccessPointName = function (resource) {\n  if (resource.indexOf(\"accesspoint:\") !== 0 && resource.indexOf(\"accesspoint/\") !== 0) {\n    throw new Error(\"Access point ARN resource should begin with 'accesspoint/'\");\n  }\n\n  var parsedResource = resource.split(resource[\"accesspoint\".length]);\n\n  if (parsedResource.length !== 2 || parsedResource[1] === \"\") {\n    throw new Error(\"Access Point ARN should have one resource accesspoint/{accesspointname}\");\n  }\n\n  return parsedResource[1];\n};","map":{"version":3,"sources":["../../src/bucketHostnameUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { ARN } from \"@aws-sdk/util-arn-parser\";\n\nconst DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nconst IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nconst DOTS_PATTERN = /\\.\\./;\nexport const DOT_PATTERN = /\\./;\nexport const S3_HOSTNAME_PATTERN = /^(.+\\.)?s3[.-]([a-z0-9-]+)\\./;\nconst S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\\.amazonaws\\.com$/;\nconst AWS_PARTITION_SUFFIX = \"amazonaws.com\";\n\nexport interface AccessPointArn extends ARN {\n  accessPointName: string;\n}\n\nexport interface BucketHostnameParams {\n  baseHostname: string;\n  bucketName: string;\n  accelerateEndpoint?: boolean;\n  dualstackEndpoint?: boolean;\n  pathStyleEndpoint?: boolean;\n  tlsCompatible?: boolean;\n}\n\nexport interface ArnHostnameParams extends Omit<BucketHostnameParams, \"bucketName\"> {\n  bucketName: ARN;\n  clientSigningRegion?: string;\n  clientPartition?: string;\n  useArnRegion?: boolean;\n}\n\nexport const isBucketNameOptions = (\n  options: BucketHostnameParams | ArnHostnameParams\n): options is BucketHostnameParams => typeof options.bucketName === \"string\";\n\nexport const getPseudoRegion = (region: string) => (isFipsRegion(region) ? region.replace(/fips-|-fips/, \"\") : region);\n\n/**\n * Determines whether a given string is DNS compliant per the rules outlined by\n * S3. Length, capitaization, and leading dot restrictions are enforced by the\n * DOMAIN_PATTERN regular expression.\n *\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n */\nexport const isDnsCompatibleBucketName = (bucketName: string): boolean =>\n  DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\n\nconst getRegionalSuffix = (hostname: string): [string, string] => {\n  const parts = hostname.match(S3_HOSTNAME_PATTERN)!;\n  return [parts[2], hostname.replace(new RegExp(`^${parts[0]}`), \"\")];\n};\n\nexport const getSuffix = (hostname: string): [string, string] =>\n  S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [\"us-east-1\", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n\nexport const getSuffixForArnEndpoint = (hostname: string): [string, string] =>\n  S3_US_EAST_1_ALTNAME_PATTERN.test(hostname)\n    ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, \"\"), AWS_PARTITION_SUFFIX]\n    : getRegionalSuffix(hostname);\n\nexport const validateService = (service: string) => {\n  if (service !== \"s3\") {\n    throw new Error(\"Expect 's3' in access point ARN service component\");\n  }\n};\n\nexport const validatePartition = (partition: string, options: { clientPartition: string }) => {\n  if (partition !== options.clientPartition) {\n    throw new Error(`Partition in ARN is incompatible, got \"${partition}\" but expected \"${options.clientPartition}\"`);\n  }\n};\n\nexport const validateRegion = (\n  region: string,\n  options: {\n    useArnRegion?: boolean;\n    clientRegion: string;\n    clientSigningRegion: string;\n  }\n) => {\n  if (region === \"\") {\n    throw new Error(\"Access point ARN region is empty\");\n  }\n  if (\n    !options.useArnRegion &&\n    !isEqualRegions(region, options.clientRegion) &&\n    !isEqualRegions(region, options.clientSigningRegion)\n  ) {\n    throw new Error(`Region in ARN is incompatible, got ${region} but expected ${options.clientRegion}`);\n  }\n  if (options.useArnRegion && isFipsRegion(region)) {\n    throw new Error(\"Access point endpoint does not support FIPS region\");\n  }\n};\n\nconst isFipsRegion = (region: string) => region.startsWith(\"fips-\") || region.endsWith(\"-fips\");\n\nconst isEqualRegions = (regionA: string, regionB: string) =>\n  regionA === regionB || getPseudoRegion(regionA) === regionB || regionA === getPseudoRegion(regionB);\n\nexport const validateAccountId = (accountId: string) => {\n  if (!/[0-9]{12}/.exec(accountId)) {\n    throw new Error(\"Access point ARN accountID does not match regex '[0-9]{12}'\");\n  }\n};\n\nexport const validateDNSHostLabel = (label: string, options: { tlsCompatible?: boolean } = { tlsCompatible: true }) => {\n  // reference: https://tools.ietf.org/html/rfc3986#section-3.2.2\n  if (\n    label.length >= 64 ||\n    !/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(label) ||\n    /(\\d+\\.){3}\\d+/.test(label) ||\n    /[.-]{2}/.test(label) ||\n    (options?.tlsCompatible && DOT_PATTERN.test(label))\n  ) {\n    throw new Error(`Invalid DNS label ${label}`);\n  }\n};\n\nexport const getAccessPointName = (resource: string): string => {\n  if (resource.indexOf(\"accesspoint:\") !== 0 && resource.indexOf(\"accesspoint/\") !== 0) {\n    throw new Error(\"Access point ARN resource should begin with 'accesspoint/'\");\n  }\n  const parsedResource = resource.split(resource[\"accesspoint\".length]);\n  if (parsedResource.length !== 2 || parsedResource[1] === \"\") {\n    throw new Error(\"Access Point ARN should have one resource accesspoint/{accesspointname}\");\n  }\n  return parsedResource[1];\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}