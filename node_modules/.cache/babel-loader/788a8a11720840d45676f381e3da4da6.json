{"ast":null,"code":"import { __read } from \"tslib\";\nimport { DOT_PATTERN, getAccessPointName, getSuffix, getSuffixForArnEndpoint, isBucketNameOptions, isDnsCompatibleBucketName, S3_HOSTNAME_PATTERN, validateAccountId, validateDNSHostLabel, validatePartition, validateRegion, validateService } from \"./bucketHostnameUtils\";\nexport var bucketHostname = function (options) {\n  var baseHostname = options.baseHostname;\n\n  if (!S3_HOSTNAME_PATTERN.test(baseHostname)) {\n    return {\n      bucketEndpoint: false,\n      hostname: baseHostname\n    };\n  }\n\n  if (isBucketNameOptions(options)) {\n    // Construct endpoint when bucketName is a string referring to a bucket name\n    return getEndpointFromBucketName(options);\n  } else {\n    // Construct endpoint when bucketName is an ARN referring to an S3 resource like Access Point\n    return {\n      bucketEndpoint: true,\n      hostname: getEndpointFromAccessPoint(options)\n    };\n  }\n};\n\nvar getEndpointFromAccessPoint = function (options) {\n  // Infer client region and hostname suffix from hostname from endpoints.json, like `s3.us-west-2.amazonaws.com`\n  var _a = __read(getSuffixForArnEndpoint(options.baseHostname), 2),\n      clientRegion = _a[0],\n      hostnameSuffix = _a[1];\n\n  var pathStyleEndpoint = options.pathStyleEndpoint,\n      dualstackEndpoint = options.dualstackEndpoint,\n      accelerateEndpoint = options.accelerateEndpoint,\n      _b = options.tlsCompatible,\n      tlsCompatible = _b === void 0 ? true : _b,\n      useArnRegion = options.useArnRegion,\n      bucketName = options.bucketName,\n      _c = options.clientPartition,\n      clientPartition = _c === void 0 ? \"aws\" : _c,\n      _d = options.clientSigningRegion,\n      clientSigningRegion = _d === void 0 ? clientRegion : _d;\n\n  if (pathStyleEndpoint) {\n    throw new Error(\"Path-style S3 endpoint is not supported when bucket is an Access Point ARN\");\n  }\n\n  if (accelerateEndpoint) {\n    throw new Error(\"Accelerate is not supported when bucket is an Access Point ARN\");\n  }\n\n  if (!tlsCompatible) {\n    throw new Error(\"Access Point can only be used with https\");\n  } // Validate and parse the ARN supplied as a bucket name\n\n\n  var service = bucketName.service,\n      partition = bucketName.partition,\n      accountId = bucketName.accountId,\n      region = bucketName.region,\n      resource = bucketName.resource;\n  validateService(service);\n  validateRegion(region, {\n    useArnRegion: useArnRegion,\n    clientRegion: clientRegion,\n    clientSigningRegion: clientSigningRegion\n  });\n  validatePartition(partition, {\n    clientPartition: clientPartition\n  });\n  validateAccountId(accountId);\n  var accessPointName = getAccessPointName(resource);\n  validateDNSHostLabel(accessPointName + \"-\" + accountId, {\n    tlsCompatible: tlsCompatible\n  });\n  return accessPointName + \"-\" + accountId + \".s3-accesspoint\" + (dualstackEndpoint ? \".dualstack\" : \"\") + \".\" + (useArnRegion ? region : clientRegion) + \".\" + hostnameSuffix;\n};\n\nvar getEndpointFromBucketName = function (_a) {\n  var _b = _a.accelerateEndpoint,\n      accelerateEndpoint = _b === void 0 ? false : _b,\n      baseHostname = _a.baseHostname,\n      bucketName = _a.bucketName,\n      _c = _a.dualstackEndpoint,\n      dualstackEndpoint = _c === void 0 ? false : _c,\n      _d = _a.pathStyleEndpoint,\n      pathStyleEndpoint = _d === void 0 ? false : _d,\n      _e = _a.tlsCompatible,\n      tlsCompatible = _e === void 0 ? true : _e;\n\n  var _f = __read(getSuffix(baseHostname), 2),\n      clientRegion = _f[0],\n      hostnameSuffix = _f[1];\n\n  if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || tlsCompatible && DOT_PATTERN.test(bucketName)) {\n    return {\n      bucketEndpoint: false,\n      hostname: dualstackEndpoint ? \"s3.dualstack.\" + clientRegion + \".\" + hostnameSuffix : baseHostname\n    };\n  }\n\n  if (accelerateEndpoint) {\n    baseHostname = \"s3-accelerate\" + (dualstackEndpoint ? \".dualstack\" : \"\") + \".\" + hostnameSuffix;\n  } else if (dualstackEndpoint) {\n    baseHostname = \"s3.dualstack.\" + clientRegion + \".\" + hostnameSuffix;\n  }\n\n  return {\n    bucketEndpoint: true,\n    hostname: bucketName + \".\" + baseHostname\n  };\n};","map":{"version":3,"sources":["../../src/bucketHostname.ts"],"names":[],"mappings":";AAAA,SAGE,WAHF,EAIE,kBAJF,EAKE,SALF,EAME,uBANF,EAOE,mBAPF,EAQE,yBARF,EASE,mBATF,EAUE,iBAVF,EAWE,oBAXF,EAYE,iBAZF,EAaE,cAbF,EAcE,eAdF,QAeO,uBAfP;AAsBA,OAAO,IAAM,cAAc,GAAG,UAAC,OAAD,EAAkD;AACtE,MAAA,YAAY,GAAK,OAAO,CAAZ,YAAZ;;AACR,MAAI,CAAC,mBAAmB,CAAC,IAApB,CAAyB,YAAzB,CAAL,EAA6C;AAC3C,WAAO;AACL,MAAA,cAAc,EAAE,KADX;AAEL,MAAA,QAAQ,EAAE;AAFL,KAAP;AAID;;AACD,MAAI,mBAAmB,CAAC,OAAD,CAAvB,EAAkC;AAChC;AACA,WAAO,yBAAyB,CAAC,OAAD,CAAhC;AACD,GAHD,MAGO;AACL;AACA,WAAO;AACL,MAAA,cAAc,EAAE,IADX;AAEL,MAAA,QAAQ,EAAE,0BAA0B,CAAC,OAAD;AAF/B,KAAP;AAID;AACF,CAlBM;;AAoBP,IAAM,0BAA0B,GAAG,UAAC,OAAD,EAA2B;AAC5D;AACM,MAAA,EAAA,GAAA,MAAA,CAAiC,uBAAuB,CAAC,OAAO,CAAC,YAAT,CAAxD,EAA8E,CAA9E,CAAA;AAAA,MAAC,YAAY,GAAA,EAAA,CAAA,CAAA,CAAb;AAAA,MAAe,cAAc,GAAA,EAAA,CAAA,CAAA,CAA7B;;AAEJ,MAAA,iBAAiB,GAQf,OAAO,CARQ,iBAAjB;AAAA,MACA,iBAAiB,GAOf,OAAO,CAPQ,iBADjB;AAAA,MAEA,kBAAkB,GAMhB,OAAO,CANS,kBAFlB;AAAA,MAGA,EAAA,GAKE,OAAO,CALW,aAHpB;AAAA,MAGA,aAAa,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,EAHpB;AAAA,MAIA,YAAY,GAIV,OAAO,CAJG,YAJZ;AAAA,MAKA,UAAU,GAGR,OAAO,CAHC,UALV;AAAA,MAMA,EAAA,GAEE,OAAO,CAFc,eANvB;AAAA,MAMA,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EANvB;AAAA,MAOA,EAAA,GACE,OAAO,CADyB,mBAPlC;AAAA,MAOA,mBAAmB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,YAAH,GAAe,EAPlC;;AAUF,MAAI,iBAAJ,EAAuB;AACrB,UAAM,IAAI,KAAJ,CAAU,4EAAV,CAAN;AACD;;AACD,MAAI,kBAAJ,EAAwB;AACtB,UAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACD;;AACD,MAAI,CAAC,aAAL,EAAoB;AAClB,UAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACD,GAtB2D,CAuB5D;;;AACQ,MAAA,OAAO,GAA6C,UAAU,CAAvD,OAAP;AAAA,MAAS,SAAS,GAAkC,UAAU,CAA5C,SAAlB;AAAA,MAAoB,SAAS,GAAuB,UAAU,CAAjC,SAA7B;AAAA,MAA+B,MAAM,GAAe,UAAU,CAAzB,MAArC;AAAA,MAAuC,QAAQ,GAAK,UAAU,CAAf,QAA/C;AACR,EAAA,eAAe,CAAC,OAAD,CAAf;AACA,EAAA,cAAc,CAAC,MAAD,EAAS;AAAE,IAAA,YAAY,EAAA,YAAd;AAAgB,IAAA,YAAY,EAAA,YAA5B;AAA8B,IAAA,mBAAmB,EAAA;AAAjD,GAAT,CAAd;AACA,EAAA,iBAAiB,CAAC,SAAD,EAAY;AAAE,IAAA,eAAe,EAAA;AAAjB,GAAZ,CAAjB;AACA,EAAA,iBAAiB,CAAC,SAAD,CAAjB;AACA,MAAM,eAAe,GAAG,kBAAkB,CAAC,QAAD,CAA1C;AACA,EAAA,oBAAoB,CAAI,eAAe,GAAA,GAAf,GAAmB,SAAvB,EAAoC;AAAE,IAAA,aAAa,EAAA;AAAf,GAApC,CAApB;AAEA,SAAU,eAAe,GAAA,GAAf,GAAmB,SAAnB,GAA4B,iBAA5B,IAA8C,iBAAiB,GAAG,YAAH,GAAkB,EAAjF,IAAmF,GAAnF,IACR,YAAY,GAAG,MAAH,GAAY,YADhB,IAC4B,GAD5B,GAEN,cAFJ;AAGD,CAnCD;;AAqCA,IAAM,yBAAyB,GAAG,UAAC,EAAD,EAOX;MANrB,EAAA,GAAA,EAAA,CAAA,kB;MAAA,kBAAkB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MAC1B,YAAY,GAAA,EAAA,CAAA,Y;MACZ,UAAU,GAAA,EAAA,CAAA,U;MACV,EAAA,GAAA,EAAA,CAAA,iB;MAAA,iBAAiB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MACzB,EAAA,GAAA,EAAA,CAAA,iB;MAAA,iBAAiB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MACzB,EAAA,GAAA,EAAA,CAAA,a;MAAA,aAAa,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,E;;AAEd,MAAA,EAAA,GAAA,MAAA,CAAiC,SAAS,CAAC,YAAD,CAA1C,EAAwD,CAAxD,CAAA;AAAA,MAAC,YAAY,GAAA,EAAA,CAAA,CAAA,CAAb;AAAA,MAAe,cAAc,GAAA,EAAA,CAAA,CAAA,CAA7B;;AACN,MAAI,iBAAiB,IAAI,CAAC,yBAAyB,CAAC,UAAD,CAA/C,IAAgE,aAAa,IAAI,WAAW,CAAC,IAAZ,CAAiB,UAAjB,CAArF,EAAoH;AAClH,WAAO;AACL,MAAA,cAAc,EAAE,KADX;AAEL,MAAA,QAAQ,EAAE,iBAAiB,GAAG,kBAAgB,YAAhB,GAA4B,GAA5B,GAAgC,cAAnC,GAAsD;AAF5E,KAAP;AAID;;AAED,MAAI,kBAAJ,EAAwB;AACtB,IAAA,YAAY,GAAG,mBAAgB,iBAAiB,GAAG,YAAH,GAAkB,EAAnD,IAAqD,GAArD,GAAyD,cAAxE;AACD,GAFD,MAEO,IAAI,iBAAJ,EAAuB;AAC5B,IAAA,YAAY,GAAG,kBAAgB,YAAhB,GAA4B,GAA5B,GAAgC,cAA/C;AACD;;AAED,SAAO;AACL,IAAA,cAAc,EAAE,IADX;AAEL,IAAA,QAAQ,EAAK,UAAU,GAAA,GAAV,GAAc;AAFtB,GAAP;AAID,CA1BD","sourcesContent":["import {\n  ArnHostnameParams,\n  BucketHostnameParams,\n  DOT_PATTERN,\n  getAccessPointName,\n  getSuffix,\n  getSuffixForArnEndpoint,\n  isBucketNameOptions,\n  isDnsCompatibleBucketName,\n  S3_HOSTNAME_PATTERN,\n  validateAccountId,\n  validateDNSHostLabel,\n  validatePartition,\n  validateRegion,\n  validateService,\n} from \"./bucketHostnameUtils\";\n\nexport interface BucketHostname {\n  hostname: string;\n  bucketEndpoint: boolean;\n}\n\nexport const bucketHostname = (options: BucketHostnameParams | ArnHostnameParams): BucketHostname => {\n  const { baseHostname } = options;\n  if (!S3_HOSTNAME_PATTERN.test(baseHostname)) {\n    return {\n      bucketEndpoint: false,\n      hostname: baseHostname,\n    };\n  }\n  if (isBucketNameOptions(options)) {\n    // Construct endpoint when bucketName is a string referring to a bucket name\n    return getEndpointFromBucketName(options);\n  } else {\n    // Construct endpoint when bucketName is an ARN referring to an S3 resource like Access Point\n    return {\n      bucketEndpoint: true,\n      hostname: getEndpointFromAccessPoint(options),\n    };\n  }\n};\n\nconst getEndpointFromAccessPoint = (options: ArnHostnameParams): string => {\n  // Infer client region and hostname suffix from hostname from endpoints.json, like `s3.us-west-2.amazonaws.com`\n  const [clientRegion, hostnameSuffix] = getSuffixForArnEndpoint(options.baseHostname);\n  const {\n    pathStyleEndpoint,\n    dualstackEndpoint,\n    accelerateEndpoint,\n    tlsCompatible = true,\n    useArnRegion,\n    bucketName,\n    clientPartition = \"aws\",\n    clientSigningRegion = clientRegion,\n  } = options;\n\n  if (pathStyleEndpoint) {\n    throw new Error(\"Path-style S3 endpoint is not supported when bucket is an Access Point ARN\");\n  }\n  if (accelerateEndpoint) {\n    throw new Error(\"Accelerate is not supported when bucket is an Access Point ARN\");\n  }\n  if (!tlsCompatible) {\n    throw new Error(\"Access Point can only be used with https\");\n  }\n  // Validate and parse the ARN supplied as a bucket name\n  const { service, partition, accountId, region, resource } = bucketName;\n  validateService(service);\n  validateRegion(region, { useArnRegion, clientRegion, clientSigningRegion });\n  validatePartition(partition, { clientPartition });\n  validateAccountId(accountId);\n  const accessPointName = getAccessPointName(resource);\n  validateDNSHostLabel(`${accessPointName}-${accountId}`, { tlsCompatible });\n\n  return `${accessPointName}-${accountId}.s3-accesspoint${dualstackEndpoint ? \".dualstack\" : \"\"}.${\n    useArnRegion ? region : clientRegion\n  }.${hostnameSuffix}`;\n};\n\nconst getEndpointFromBucketName = ({\n  accelerateEndpoint = false,\n  baseHostname,\n  bucketName,\n  dualstackEndpoint = false,\n  pathStyleEndpoint = false,\n  tlsCompatible = true,\n}: BucketHostnameParams): BucketHostname => {\n  const [clientRegion, hostnameSuffix] = getSuffix(baseHostname);\n  if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || (tlsCompatible && DOT_PATTERN.test(bucketName))) {\n    return {\n      bucketEndpoint: false,\n      hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname,\n    };\n  }\n\n  if (accelerateEndpoint) {\n    baseHostname = `s3-accelerate${dualstackEndpoint ? \".dualstack\" : \"\"}.${hostnameSuffix}`;\n  } else if (dualstackEndpoint) {\n    baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;\n  }\n\n  return {\n    bucketEndpoint: true,\n    hostname: `${bucketName}.${baseHostname}`,\n  };\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}